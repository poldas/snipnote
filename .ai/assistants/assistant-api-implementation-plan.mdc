Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Poniżej znajdziesz plan api, plan bazy danych, stack technologiczny i zasady implementacji. Twoim zadaniem jest stworzenie szczegółowego planu implementacji endpontów odpowiedzialnych za notatki Notes.
Base path: `/api/notes`

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:

Route API specification:
<route_api_specification>
### Notes

Base path: `/api/notes`

#### Create note

Method:`POST`
Path:`/api/notes`
Auth required:Yes
Description:Create a new note; server generates `url_token` (UUIDv4) on first save. Default `visibility=private`.
Request JSON:

```json
{
  "title": "My recipe",
  "description": "Markdown content...",
  "labels": ["dessert żółć","baking kick"],
  "visibility": "private"  // optional, allowed: "private","public","draft"
}
```

Response 201:

```json
{
  "data": {
    "id": 10,
    "owner_id": 123,
    "url_token": "uuid-v4",
    "title": "...",
    "description": "...",
    "labels": ["dessert żółć","baking kick"],
    "visibility": "private",
    "created_at": "...",
    "updated_at": "..."
  }
}
```

Errors:`400` validation (title/description length), `401` unauthorized.

Notes:`url_token` generation must be attempted in transaction; on UUID collision return `409` and retry at application level.

#### Read note (by ID) — owner/collaborator view

Method:`GET`
Path:`/api/notes/{id}`
Auth required:Yes (only owners/collaborators)
Response 200:note object (same as above)
Errors:`403` forbidden, `404` not found.

#### Public read by token (public notes)

Method:`GET`
Path:`/api/public/notes/{url_token}`
Auth required:No
Description:Returns rendered metadata and full `description` (markdown rendered on client). Only returns content if note `visibility='public'`.
Response 200:

```json
{
  "data": {
    "title": "...",
    "description": "...",
    "labels": [...],
    "created_at": "..."
  }
}
```

Errors:`404` not found or `403` if note exists but not public.

#### Update note

Method:`PATCH`
Path:`/api/notes/{id}`
Auth required:Yes (owner or collaborator)
Request JSON:any subset of fields:

```json
{
  "title": "New title",
  "description": "updated markdown",
  "labels": ["a","b"],
  "visibility": "public"
}
```

Behavior:Changes saved only on explicit save. If `url_token` was regenerated client must persist change.
Response 200:updated note object
Errors:`400` validation, `403` unauthorized, `404` not found.

#### Delete note

Method:`DELETE`
Path:`/api/notes/{id}`
Auth required:Yes (owner only)
Response:`204 No Content`
Behavior:DB `ON DELETE CASCADE` ensures `note_collaborators` removed. Application must ensure logging and redirect.
Errors:`403`, `404`.
</route_api_specification>

Related database resources:
<related_db_resources>
### `users`

```sql
CREATE TABLE users (
  id                BIGSERIAL PRIMARY KEY,
  uuid              UUID NOT NULL DEFAULT gen_random_uuid(), -- publiczny identyfikator katalogu użytkownika
  email             TEXT NOT NULL,
  password_hash     TEXT NOT NULL,
  created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

Ograniczenia / uwagi:

* Unikalność email case-insensitive realizujemy indeksem `UNIQUE (lower(email))`.
* `uuid` używany publicznie (katalog użytkownika).

---

### `notes`

```sql
CREATE TYPE note_visibility AS ENUM ('public','private','draft');

CREATE TABLE notes (
  id                  BIGSERIAL PRIMARY KEY,
  owner_id            BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  url_token           UUID NOT NULL UNIQUE, -- publiczny losowy token (UUIDv4)
  title               TEXT NOT NULL,        -- walidacje długości w aplikacji (<=255)
  description         TEXT NOT NULL,        -- markdown, walidacja długości w aplikacji
  labels              TEXT[] NOT NULL DEFAULT '{}', -- lokalne labeli dla notatki
  visibility          note_visibility NOT NULL DEFAULT 'private',
  search_vector_simple tsvector,            -- tsvector (konfiguracja 'simple')
  created_at          TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at          TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

Ograniczenia / uwagi:

* `url_token` — UUIDv4, unikalny. Przy kolizji aplikacja powinna zwrócić błąd (409) i ponowić generację.
* Brak DB CHECK dla długości pól (walidacja w aplikacji — zgodnie z decyzją).

---

### `note_collaborators`

```sql
CREATE TABLE note_collaborators (
  id          BIGSERIAL PRIMARY KEY,
  note_id     BIGINT NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  email       TEXT NOT NULL,          -- adres e-mail współedytora (zapisany jak wpisany)
  user_id     BIGINT NULL REFERENCES users(id) ON DELETE SET NULL, -- automatyczne powiązanie po rejestracji
  created_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```
</related_db_resources>

Tech stack:
<tech_stack>
### Tech stack / środowisko
#### Backend
PHP 8.2
Symfony 7.3 (attributes dla routingu, DI, Doctrine)
Doctrine ORM 3+ (+ doctrine/migrations)
maker-bundle do scaffoldingu
PostgreSQL (dev/test/prod)

#### Frontend
Twig jako główny templating
HTMX 2+ do partial refresh / formularzy / list
Tailwind CSS jako jedyny system styli (opcjonalny prosty build)
Minimalny vanilla JS tylko tam, gdzie HTMX nie wystarcza

#### Autoryzacja (PostgreSQL + Symfony)
Wbudowany Symfony Security (authenticator-based)
Użytkownicy i sesje trzymane w PostgreSQL (encje User, tabele auth)
Password hashing: native password hasher (argon2id / bcrypt)
JWT: lexik/jwt-authentication-bundle do wystawiania i weryfikacji tokenów
(Opcjonalnie) refresh tokens: gesdinet/jwt-refresh-token-bundle
Role i uprawnienia przez role hierarchy + Voter dla reguł domenowych

#### API / komunikacja
Standard: klasyczne kontrolery Symfony (HTML + JSON)

#### Docker / infra
Docker Compose: php-fpm 8.2, nginx, postgres (+ ewentualnie mailhog)
Konfiguracja kompatybilna z uruchomieniem CLI: `php bin/console`, `phpunit`, `phpstan`

#### Testy / jakość
PHPUnit + Symfony test tools
DoctrineFixturesBundle / własne seedy do danych testowych
PHP-CS-Fixer (PSR-12)
PHPStan na poziomie 5
Symfony Profiler + Monolog dla debugowania/obserwowalności
</tech_stack>

Implementation rules:
<implementation_rules>
### Ogólne zasady AI / Cursor
- Scope patcha: generuj mały, spójny patch (diff) zawierający tylko powiązane pliki (entity, repo, service, controller, twig, migration, test). Max ~500 LOC.
- Commit format: <scope>: <krótkie-opis> (np. notes: add label index migration).
- Jeśli brakuje danych niezbędnych do implementacji → odpowiedz nie wiem i zaproponuj 2 warianty implementacji.
- Zawsze dołącz krótkie 1–2 zdania trade-offs (szybkość vs utrzymanie).
- Generuj unified diff (nie pełne pliki, jeśli możliwe).
- Jeżeli zmienia się DB: dołącz Doctrine migration, surowe SQL, oraz krótki rollback plan.
- Załącz kontekst plików: entity, repo, service, controller, twig (jeśli dotyczy).
- DB change → dołącz migration + surowe SQL + rollback note.
- Testy: dołącz minimalny test dla zmian domenowych/auth. Drobne view-only changes mogą pójść bez testu.
- Lint & static checks: generuj kod zgodny z PSR-12; uruchom PHP-CS-Fixer i PHPStan (lvl 5).
- Jeśli brakuje danych wymaganych do poprawnego kodu — odpowiedz „nie wiem” i podaj 2 alternatywy realizacji.
- Docker-readiness: wygenerowany kod powinien działać w standardowym obrazie PHP-FPM 8.2 + nginx + postgres; dołącz modyfikację docker-compose tylko gdy konieczne.
- Max LOC per patch: 500 LOC; jeśli potrzeba więcej, rozbij na spójne patchy.
- Implement → Test → Feedback never 50 features then test.

### Symfony & Doctrine
Architektura: prosty podział — Entity → Repository → Service (logika domenowa) → Controller (thin). Nie pełne DDD, tylko jawne granice.
- Target: Symfony 7.3. Preferuj attributes (routing, DI, Doctrine mapping).
- Kontrolery: thin — logika w serwisach.
- DI: wstrzykiwanie zależności, unikaj statycznych helperów.
- Formularze: Symfony Forms + Validator (server authoritative).
- Używaj QueryBuilder/DTO, unikaj nadmiernej hydracji, profiluj zapytania i dodaj indeksy tam, gdzie wyszukiwanie (title/description/labels) jest krytyczne
- Standard: Kod: PSR-12; typowanie parametrów/metod; PHPStan poziom 5 (MVP), phpVersion: 8.2.
- Typowanie: wymagane dla parametrów i zwracanych wartości; używaj union types, promoted properties, readonly tam gdzie sensowne.
- Używaj maker:bundle do scaffoldingu, ale ręcznie dopracowuj wygenerowany kod.
- Mapowania: PHP attributes preferowane dla Symfony i Doctrine
- Stosuj gotowe i sprawdzone już rozwiązania i pakiety np. stosujesz gotowe pakiety (Supabase Auth + Storage, Symfony + API Platform/lexik/jwt lub prosty JWT verification),

### Frontend (UI) — reguły (Twig + HTMX 2+ + Tailwind)
- Komponenty: małe, pojedyncze partiale Twig (max ~200 LOC).
- Każdy partial ma jasno zdefiniowane wejście (parametry) i nie trzyma logiki domenowej.
- Interakcje: HTMX tylko dla prostych fragmentów (formularze, listy, podgląd).
- Dla złożonych interakcji wyodrębnij osobny endpoint lub rozważ mały komponent JS.
- Styling: Tailwind utility-first; nie generuj nadmiarowych klas — preferuj zwięzłe klasy i tokeny w tailwind.config.
- Markdown: renderowanie po stronie serwera; zawsze sanitizuj HTML przed wysłaniem do klienta.
- Formularze: używaj Symfony Forms → prosty rendering Twig; walidacja zarówno klient + server (server authoritative).
- Accessibility: pola formularzy powinny mieć label, błędy przy polach, keyboard focus dla modali.
- Size limit: pliki JS/CSS minimalne; brak bundlera-heavy konfiguracji w MVP — opcjonalny build step dla Tailwind.

### Autoryzacja
- użyj Supabase Auth dla logowania, Symfony tylko weryfikuje JWT przy żądaniach (biblioteka jwt, middleware), dla operacji serwerowych użyj service key tylko na backendzie, nie pisz auth od zera.
- używaj istniejących Symfony bundles.
</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu interfejsu API REST. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 401 dla nieautoryzowanego dostępu
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown.
Oto jak powinny wyglądać dane wyjściowe:

```markdown
# API Endpoint Implementation Plan: [endpoint-name]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PUT/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1]
2. [Krok 2]
3. [Krok 3]
...
```

Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.

Końcowy plan powinien być możliwy do skopiowania i wklejenia do pliku.