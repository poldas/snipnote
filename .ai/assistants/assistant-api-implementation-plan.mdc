Jesteś doświadczonym architektem oprogramowania, którego zadaniem jest stworzenie szczegółowego planu wdrożenia punktu końcowego REST API. Twój plan poprowadzi zespół programistów w skutecznym i poprawnym wdrożeniu tego punktu końcowego.

Poniżej znajdziesz plan api, plan bazy danych, stack technologiczny i zasady implementacji. Twoim zadaniem jest stworzenie szczegółowego planu implementacji endpontów odpowiedzialnych autryzację, rejestrację, logowanie, przypomnienie hasła, wysyłkę linku do weryfikacji i jego obsługę.

Zanim zaczniemy, zapoznaj się z poniższymi informacjami:
Specyfikacja autoryzacji
<auth_specification>
# Specyfikacja architektury autentykacji (UI + API)

## Kontekst i cele
- Zakres: US-010 Rejestracja, US-011 Logowanie, US-012 Wylogowanie; zintegrowane z istniejącym UI (Twig + HTMX) i backendem Symfony 8 + Doctrine/PostgreSQL.
- UI używa wyłącznie sesji Symfony (cookie + CSRF). JWT używany tylko dla `/api/*`.
- Wspólne źródło prawdy: encja `User` w PostgreSQL zarządzana przez Doctrine.
- Maile (verify/reset) współdzielone między UI i API; jedyna zmienna między środowiskami to `MAILER_DSN`.

## 1. Architektura interfejsu użytkownika (Twig + HTMX)

### Layouty i tryby
- **Anon layout**: strony `/login`, `/register`, `/forgot-password`, `/reset-password/{token}`, `/verify/email`. Minimalny topbar (logo + link do logowania/rejestracji), bez sidebaru. Formularze z CSRF.
- **Auth layout**: widoki aplikacji (`/notes/*`). Menu użytkownika zawiera „Wyloguj” (POST z CSRF).
- **HTMX**: używane do wstrzykiwania fragmentów z błędami walidacji (hx-target na wrapperze formularza) i ewentualnych toastów; pełne przeładowania dla przejść między widokami.

### Strony i komponenty
- **Login (`/login`, GET/POST)**: pola email, hasło; checkbox „Zapamiętaj” (remember_me). Po sukcesie redirect na `/notes`. Przy `isVerified=false` zamiast logowania renderowana strona „Sprawdź maila, aby aktywować konto” (bez ujawniania stanu konta innym).
- **Register (`/register`, GET/POST)**: pola email, hasło (min. 8), checkbox zgody (jeśli wymagane prawnie). Po sukcesie: automatyczne zalogowanie sesyjne, redirect na stronę „Sprawdź maila” (blokada akcji wymagających weryfikacji). Komunikat o wysłaniu maila aktywacyjnego.
- **Verify email (`/verify/email?signature=...`)**: wynik VerifyEmailBundle (success → redirect do `/notes` lub strony potwierdzenia; failure → komunikat „link wygasł / nieważny” + przycisk „Wyślij ponownie”).
- **Forgot password (`/forgot-password`, GET/POST)**: pole email; po submit zawsze ten sam komunikat „Jeśli konto istnieje, wysłaliśmy instrukcje”. Brak ujawniania istnienia konta.
- **Reset password (`/reset-password/{token}`, GET/POST)**: pola nowe hasło + powtórzenie; po sukcesie automatyczne zalogowanie i redirect na `/notes`.
- **Logout (`/logout`, POST)**: formularz ukryty w menu użytkownika, CSRF.

### Walidacja i komunikaty (UI)
- Email: format RFC, komunikat „Podaj poprawny adres email”.
- Hasło: min. 8 znaków (PSR-12 msg), komunikat „Hasło musi mieć min. 8 znaków”.
- Pole wymagane: „To pole jest wymagane”.
- Błędy serwera 400: inline pod polem; 401/403: globalny alert „Brak dostępu / konto nieweryfikowane”; 429: alert „Za dużo prób, spróbuj ponownie później”; 5xx: toast „Coś poszło nie tak”.

### Scenariusze kluczowe
- Nowy użytkownik → `/register` → po sukcesie komunikat „Sprawdź maila” → klik link w mailu → `/verify/email` → redirect do `/notes`.
- Istniejący, niezweryfikowany → próba logowania → komunikat o konieczności weryfikacji + link do ponownego wysłania maila.
- Zapomniane hasło → `/forgot-password` → otrzymany link → `/reset-password/{token}` → ustawienie nowego hasła → redirect `/notes`.
- Wylogowanie → POST `/logout` → redirect na landing.

## 2. Logika backendowa

### Model danych (Doctrine)
- Encja `User` (tabela `users`): id (uuid/ulid), email (unikalny, lowercase), `password` (hash), `roles` (JSON), `isVerified` (bool), `createdAt/updatedAt`, opcjonalnie `lastLoginAt`.
- Provider: Doctrine user provider (email jako identyfikator).

### Walidacja (Symfony Validator)
- Email: `Email` + `NotBlank` + `Length(max=180)`.
- Hasło: `NotBlank`, `Length(min=8, max=4096)`.
- Verify/Reset tokeny walidowane przez bundlowe constrainty.
- Błędy mapowane na form errors (HTML) lub JSON `{field: [messages...]}`.

### Endpoints i rozdzielenie warstw
HTML (sesja, CSRF, Twig):
- `GET /login` (SecurityController::loginForm) + `POST /login` (Symfony authenticator).
- `POST /logout` (route only, handled by firewall).
- `GET|POST /register` (RegistrationController) → tworzy usera, hashuje hasło, wywołuje VerifyEmailHelper → wysyła mail; po sukcesie loguje użytkownika i redirect do „verify notice”.
- `GET /verify/email` (VerificationController) → VerifyEmailBundle; w razie błędu generuje formularz „wyślij ponownie”.
- `GET|POST /forgot-password` (ResetPasswordController::request) → ResetPasswordBundle request.
- `GET|POST /reset-password/{token}` (ResetPasswordController::reset) → ustawia nowe hasło, loguje użytkownika, unieważnia token.

API (JWT, bez sesji; JSON):
- `POST /api/auth/login` → weryfikacja email/hasło + `isVerified`; zwraca `{access_token, refresh_token?, expires_in}` (HS256, `sub`, `exp`, `iat`). 401 na błędne dane lub nieweryfikowane konto (bez różnicowania przyczyny).
- `POST /api/auth/refresh` (jeśli użyty gesdinet/jwt-refresh-token-bundle) → zwrot zrotowanego refresh + nowy access.
- `POST /api/auth/logout` → unieważnia refresh (np. usunięcie rekordu) i zwraca 204.
- Mechanizm reset/verify współdzielony: API może korzystać z tych samych usług (np. event listener wysyłający mail) lub wystawiać dodatkowe JSON endpoints proxy do bundli jeśli potrzebne.

### Obsługa wyjątków i bezpieczeństwo informacji
- Reset hasła: zawsze 200 z identycznym komunikatem, brak sygnalizacji istnienia konta.
- Verify email: błędy podpisu/wygaszenia → komunikat ogólny + opcja ponownego wysłania.
- Logowanie: odpowiedź 401 bez potwierdzenia, czy email istnieje lub czy konto zweryfikowane (dla API); dla UI komunikat o weryfikacji, ale bez potwierdzenia istnienia adresu.
- Rate limiting: na `/login` i `/api/auth/login` (np. `LoginRateLimiter`).

### Integracja e-mail (VerifyEmailBundle, ResetPasswordBundle)
- Wspólny `MailerInterface` + `EMAIL_FROM` (konfiguracja parameters.yaml). Szablony Twig dla maili (verify/reset) dostępne zarówno dla UI, jak i API wywołujące te same serwisy.
- Konfiguracja środowisk:
  - DEV: `MAILER_DSN=smtp://mailpit:1025` (kontener `axllent/mailpit`).
  - PROD: `MAILER_DSN` na zewnętrzny SMTP (Mailgun/SendGrid/AWS SES lub firmowy).
- Kod nie zależy od środowiska; różni się wyłącznie wartość `MAILER_DSN`.

## 3. System autentykacji i autoryzacji

### Symfony Security
- Firewalle:
  - `main` (UI): form_login authenticator + remember_me, session storage, CSRF w formach, access_control wymuszający auth na `/notes/**`, `/collaborators/**`, itp.
  - `api` (stateless): `JwtAuthenticator` (LexikJWT), bez sesji/CSRF, ścieżki `/api/**`.
- Access control:
  - Public: `/`, `/login`, `/register`, `/verify/email`, `/forgot-password`, `/reset-password/*`, `/p/*`, `/u/*`.
  - Auth required: `/notes/**` itp.; dodatkowo `isVerified()` voter/constraint blokuje nieweryfikowanych.
- Password hashing: `UserPasswordHasherInterface` (argon2id/bcrypt per Symfony defaults).
- `isVerified` enforced:
  - UI: po form_login, jeżeli `!user.isVerified`, następuje wylogowanie + redirect do „verify notice”.
  - API: login/refresh odrzuca nieweryfikowane konto (401).

### JWT (tylko API)
- Format: HS256; payload minimalnie `sub` (user id/email), `exp`, `iat`, opcjonalnie `roles`.
- Generacja: na `POST /api/auth/login`; czas życia krótki (np. 15m). Refresh token dłuższy (DB-backed, rotowany).
- Weryfikacja: `JwtAuthenticator` + `UserProvider` (Doctrine). Brak użycia JWT w UI/HTML.

### Autoryzacja domenowa
- Votery (np. `NoteVoter`): sprawdzają owner/współedytor; wykorzystywane w kontrolerach UI i API.
- Role hierarchy minimalna (`ROLE_USER` domyślna).

### Dodatkowe mechanizmy bezpieczeństwa
- CSRF w formularzach HTML (login, register, forgot, reset, logout).
- HSTS/secure cookies w prod, `SameSite=Lax`, `HttpOnly`.
- Audit/logi: zdarzenia auth (successful/failed login, password reset, verify) logowane przez Monolog.

## 4. Kontrakty UI ↔ backend (streszczenie)
- Formularze HTML wysyłają standardowe POST (nie XHR) z CSRF, otrzymują redirecty + flash messages; HTMX używany tylko do fragmentów z błędami w miejscu.
- API przyjmuje/zwra­ca JSON; kody: 200/201 na sukces, 204 na logout, 400 na walidację, 401 na auth/verify fail, 429 na rate-limit, 500 na błąd serwera.
- Brak CORS wymaganego dla UI (ten sam origin). API może wymagać CORS wyłącznie dla klientów zewnętrznych (out of MVP).

## 5. Testowalność i nieinwazyjność
- Architektura nie zmienia istniejących widoków notatek; dodaje wyłącznie nowe ścieżki auth i sprawdzenie `isVerified`.
- Weryfikacja: e2e ścieżki register→verify→login, login fail (bad credentials), login fail (unverified), forgot/reset flow, JWT login/refresh, logout (sesja i refresh).

</auth_specification>

Route API specification:
<route_api_specification>
#### List notes (dashboard — owner)

Method:`GET`
Path:`/api/notes`
Auth required:Yes
Query params:`page`, `per_page`, `q`, `label`
Behavior:Returns notes owned by current user; default sorted by `created_at DESC`. Search `q` runs full-text search against `search_vector_simple` or simple ILIKE fallback. `label` applies `labels && ARRAY[...]` (OR logic). Pagination via offset.
Response 200:

```json
{
  "data": [ { note }, ... ],
  "meta": { "page": 1, "per_page": 10, "total": 42 }
}
```

Errors:`401`.

</route_api_specification>

Related database resources:
<related_db_resources>
### `users`

```sql
CREATE TABLE users (
  id                BIGSERIAL PRIMARY KEY,
  uuid              UUID NOT NULL DEFAULT gen_random_uuid(), -- publiczny identyfikator katalogu użytkownika
  email             TEXT NOT NULL,
  password_hash     TEXT NOT NULL,
  created_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at        TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

Ograniczenia / uwagi:

* Unikalność email case-insensitive realizujemy indeksem `UNIQUE (lower(email))`.
* `uuid` używany publicznie (katalog użytkownika).

---

### `notes`

```sql
CREATE TYPE note_visibility AS ENUM ('public','private','draft');

CREATE TABLE notes (
  id                  BIGSERIAL PRIMARY KEY,
  owner_id            BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  url_token           UUID NOT NULL UNIQUE, -- publiczny losowy token (UUIDv4)
  title               TEXT NOT NULL,        -- walidacje długości w aplikacji (<=255)
  description         TEXT NOT NULL,        -- markdown, walidacja długości w aplikacji
  labels              TEXT[] NOT NULL DEFAULT '{}', -- lokalne labeli dla notatki
  visibility          note_visibility NOT NULL DEFAULT 'private',
  search_vector_simple tsvector,            -- tsvector (konfiguracja 'simple')
  created_at          TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at          TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```

Ograniczenia / uwagi:

* `url_token` — UUIDv4, unikalny. Przy kolizji aplikacja powinna zwrócić błąd (409) i ponowić generację.
* Brak DB CHECK dla długości pól (walidacja w aplikacji — zgodnie z decyzją).

---

### `note_collaborators`

```sql
CREATE TABLE note_collaborators (
  id          BIGSERIAL PRIMARY KEY,
  note_id     BIGINT NOT NULL REFERENCES notes(id) ON DELETE CASCADE,
  email       TEXT NOT NULL,          -- adres e-mail współedytora (zapisany jak wpisany)
  user_id     BIGINT NULL REFERENCES users(id) ON DELETE SET NULL, -- automatyczne powiązanie po rejestracji
  created_at  TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
```


Relacje między tabelami (kardynalność)

* `users (1) — (N) notes`
  Jeden użytkownik (owner) może mieć wiele notatek. (`notes.owner_id` → `users.id`)
* `notes (1) — (N) note_collaborators`
  Jedna notatka może mieć wielu współedytorów. (`note_collaborators.note_id` → `notes.id`)
* `users (1) — (N) note_collaborators` (opcjonalne powiązanie)
  `note_collaborators.user_id` wskazuje na `users.id` po rejestracji; powiązanie wiele-do-wielu realizowane przez `note_collaborators` + `notes.owner_id` (bez dodatkowej tabeli).

Kardynalności:

* users ↔ notes: 1:N
* notes ↔ note_collaborators: 1:N
* users ↔ note_collaborators (przez user_id): 1:N (opcjonalnie)

DDL pomocnicze: funkcja trigger i trigger do aktualizacji `search_vector_simple`

```sql
-- Funkcja aktualizująca search_vector_simple używając konfiguracji 'simple'
CREATE FUNCTION notes_search_vector_update() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.search_vector_simple := to_tsvector('simple', coalesce(NEW.title,'') || ' ' || coalesce(NEW.description,''));
  RETURN NEW;
END
$$;

-- Trigger
CREATE TRIGGER trg_notes_search_vector BEFORE INSERT OR UPDATE
  ON notes FOR EACH ROW EXECUTE FUNCTION notes_search_vector_update();
```

(Uwaga: alternatywnie można aktualizować `search_vector_simple` w warstwie aplikacji podczas zapisu.)

</related_db_resources>

Tech stack:
<tech_stack>
### Tech stack / środowisko
#### Backend
PHP 8.4
Symfony 8.0 (attributes dla routingu, DI, Doctrine)
Doctrine ORM 3.5+ (+ doctrine/migrations)
maker-bundle do scaffoldingu
PostgreSQL (dev/test/prod)

#### Frontend
Twig jako główny templating
HTMX 2+ do partial refresh / formularzy / list
Tailwind CSS jako jedyny system styli (opcjonalny prosty build)
Minimalny vanilla JS tylko tam, gdzie HTMX nie wystarcza

#### Autoryzacja (PostgreSQL + Symfony)
Wbudowany Symfony Security (authenticator-based)
Użytkownicy i sesje trzymane w PostgreSQL (encje User, tabele auth)
Password hashing: native password hasher (argon2id / bcrypt)
JWT: lexik/jwt-authentication-bundle do wystawiania i weryfikacji tokenów
(Opcjonalnie) refresh tokens: gesdinet/jwt-refresh-token-bundle
Role i uprawnienia przez role hierarchy + Voter dla reguł domenowych

#### API / komunikacja
Standard: klasyczne kontrolery Symfony (HTML + JSON)

#### Docker / infra
Docker Compose: php-fpm 8.2, nginx, postgres (+ ewentualnie mailhog)
Konfiguracja kompatybilna z uruchomieniem CLI: `php bin/console`, `phpunit`, `phpstan`

#### Testy / jakość
PHPUnit + Symfony test tools
DoctrineFixturesBundle / własne seedy do danych testowych
PHP-CS-Fixer (PSR-12)
PHPStan na poziomie 5
Symfony Profiler + Monolog dla debugowania/obserwowalności
</tech_stack>

Implementation rules:
<implementation_rules>
### Ogólne zasady AI / Cursor
- Scope patcha: generuj mały, spójny patch (diff) zawierający tylko powiązane pliki (entity, repo, service, controller, twig, migration, test). Max ~500 LOC.
- Commit format: <scope>: <krótkie-opis> (np. notes: add label index migration).
- Jeśli brakuje danych niezbędnych do implementacji → odpowiedz nie wiem i zaproponuj 2 warianty implementacji.
- Zawsze dołącz krótkie 1–2 zdania trade-offs (szybkość vs utrzymanie).
- Generuj unified diff (nie pełne pliki, jeśli możliwe).
- Jeżeli zmienia się DB: dołącz Doctrine migration, surowe SQL, oraz krótki rollback plan.
- Załącz kontekst plików: entity, repo, service, controller, twig (jeśli dotyczy).
- DB change → dołącz migration + surowe SQL + rollback note.
- Testy: dołącz minimalny test dla zmian domenowych/auth. Drobne view-only changes mogą pójść bez testu.
- Lint & static checks: generuj kod zgodny z PSR-12; uruchom PHP-CS-Fixer i PHPStan (lvl 5).
- Jeśli brakuje danych wymaganych do poprawnego kodu — odpowiedz „nie wiem” i podaj 2 alternatywy realizacji.
- Docker-readiness: wygenerowany kod powinien działać w standardowym obrazie PHP-FPM 8.2 + nginx + postgres; dołącz modyfikację docker-compose tylko gdy konieczne.
- Max LOC per patch: 500 LOC; jeśli potrzeba więcej, rozbij na spójne patchy.
- Implement → Test → Feedback never 50 features then test.

### Symfony & Doctrine
- aplikacja działa w dockerz, ZAWSZE uruchamiaj poprzez 'docker compose <command>'
- Architektura: prosty podział — Entity → Repository → Service (logika domenowa) → Controller (thin). Nie pełne DDD, tylko jawne granice.
- Target: Symfony 7.3. Preferuj attributes (routing, DI, Doctrine mapping).
- Kontrolery: thin — logika w serwisach.
- DI: wstrzykiwanie zależności, unikaj statycznych helperów.
- Formularze: Symfony Forms + Validator (server authoritative).
- Używaj QueryBuilder/DTO, unikaj nadmiernej hydracji, profiluj zapytania i dodaj indeksy tam, gdzie wyszukiwanie (title/description/labels) jest krytyczne
- Standard: Kod: PSR-12; typowanie parametrów/metod; PHPStan poziom 5 (MVP), phpVersion: 8.2.
- Typowanie: wymagane dla parametrów i zwracanych wartości; używaj union types, promoted properties, readonly tam gdzie sensowne.
- Używaj maker:bundle do scaffoldingu, ale ręcznie dopracowuj wygenerowany kod.
- Mapowania: PHP attributes preferowane dla Symfony i Doctrine
- Stosuj gotowe i sprawdzone już rozwiązania i pakiety np. stosujesz gotowe pakiety (Supabase Auth + Storage, Symfony + API Platform/lexik/jwt lub prosty JWT verification),

### Frontend (UI) — reguły (Twig + HTMX 2+ + Tailwind)
- Komponenty: małe, pojedyncze partiale Twig (max ~200 LOC).
- Każdy partial ma jasno zdefiniowane wejście (parametry) i nie trzyma logiki domenowej.
- Interakcje: HTMX tylko dla prostych fragmentów (formularze, listy, podgląd).
- Dla złożonych interakcji wyodrębnij osobny endpoint lub rozważ mały komponent JS.
- Styling: Tailwind utility-first; nie generuj nadmiarowych klas — preferuj zwięzłe klasy i tokeny w tailwind.config.
- Markdown: renderowanie po stronie serwera; zawsze sanitizuj HTML przed wysłaniem do klienta.
- Formularze: używaj Symfony Forms → prosty rendering Twig; walidacja zarówno klient + server (server authoritative).
- Accessibility: pola formularzy powinny mieć label, błędy przy polach, keyboard focus dla modali.
- Size limit: pliki JS/CSS minimalne; brak bundlera-heavy konfiguracji w MVP — opcjonalny build step dla Tailwind.

</implementation_rules>

Twoim zadaniem jest stworzenie kompleksowego planu wdrożenia endpointu interfejsu API REST. Przed dostarczeniem ostatecznego planu użyj znaczników <analysis>, aby przeanalizować informacje i nakreślić swoje podejście. W tej analizie upewnij się, że:

1. Podsumuj kluczowe punkty specyfikacji API.
2. Wymień wymagane i opcjonalne parametry ze specyfikacji API.
3. Wymień niezbędne typy DTO i Command Modele.
4. Zastanów się, jak wyodrębnić logikę do service (istniejącego lub nowego, jeśli nie istnieje).
5. Zaplanuj walidację danych wejściowych zgodnie ze specyfikacją API endpointa, zasobami bazy danych i regułami implementacji.
6. Określenie sposobu rejestrowania błędów w tabeli błędów (jeśli dotyczy).
7. Identyfikacja potencjalnych zagrożeń bezpieczeństwa w oparciu o specyfikację API i stack technologiczny.
8. Nakreśl potencjalne scenariusze błędów i odpowiadające im kody stanu.

Po przeprowadzeniu analizy utwórz szczegółowy plan wdrożenia w formacie markdown. Plan powinien zawierać następujące sekcje:

1. Przegląd punktu końcowego
2. Szczegóły żądania
3. Szczegóły odpowiedzi
4. Przepływ danych
5. Względy bezpieczeństwa
6. Obsługa błędów
7. Wydajność
8. Kroki implementacji

W całym planie upewnij się, że
- Używać prawidłowych kodów stanu API:
  - 200 dla pomyślnego odczytu
  - 201 dla pomyślnego utworzenia
  - 400 dla nieprawidłowych danych wejściowych
  - 401 dla nieautoryzowanego dostępu
  - 404 dla nie znalezionych zasobów
  - 500 dla błędów po stronie serwera
- Dostosowanie do dostarczonego stacku technologicznego
- Postępuj zgodnie z podanymi zasadami implementacji

Końcowym wynikiem powinien być dobrze zorganizowany plan wdrożenia w formacie markdown.
Oto jak powinny wyglądać dane wyjściowe:

```markdown
# API Endpoint Implementation Plan: [endpoint-name]

## 1. Przegląd punktu końcowego
[Krótki opis celu i funkcjonalności punktu końcowego]

## 2. Szczegóły żądania
- Metoda HTTP: [GET/POST/PUT/DELETE]
- Struktura URL: [wzorzec URL]
- Parametry:
  - Wymagane: [Lista wymaganych parametrów]
  - Opcjonalne: [Lista opcjonalnych parametrów]
- Request Body: [Struktura treści żądania, jeśli dotyczy]

## 3. Wykorzystywane typy
[DTOs i Command Modele niezbędne do implementacji]

## 3. Szczegóły odpowiedzi
[Oczekiwana struktura odpowiedzi i kody statusu]

## 4. Przepływ danych
[Opis przepływu danych, w tym interakcji z zewnętrznymi usługami lub bazami danych]

## 5. Względy bezpieczeństwa
[Szczegóły uwierzytelniania, autoryzacji i walidacji danych]

## 6. Obsługa błędów
[Lista potencjalnych błędów i sposób ich obsługi]

## 7. Rozważania dotyczące wydajności
[Potencjalne wąskie gardła i strategie optymalizacji]

## 8. Etapy wdrożenia
1. [Krok 1]
2. [Krok 2]
3. [Krok 3]
...
```

Końcowe wyniki powinny składać się wyłącznie z planu wdrożenia w formacie markdown i nie powinny powielać ani powtarzać żadnej pracy wykonanej w sekcji analizy.

Upewnij się, że plan jest szczegółowy, przejrzysty i zapewnia kompleksowe wskazówki dla zespołu programistów.

Końcowy plan powinien być możliwy do skopiowania i wklejenia do pliku.